# Node.js

## 파일 시스템

#### 1. fs 모듈

* 파일 시스템에 접근하는 모듈

* 일반적으로 브라우저의 자바스크립트에서는 파일 접근이 금지됨

  

  1. readFile

     readme.txt

     ```
     이것은 읽기 파일입니다.
     ```

     

     readFile.js

     ```javascript
     const fs = require("fs");
     
     fs.readFile("./readme.txt", (err, data) => {
         if(err) {
             throw err;
         }
         console.log(data);
         console.log(data.toString());
     });
     ```

     

     결과

     ![readfile](https://user-images.githubusercontent.com/20276476/74395793-9064d200-4e53-11ea-95fc-31797fbb8691.png)

     data는 버퍼 형식으로 제공됨 -> toString()을 써야 문자열로 나온다

     

  2. writeFile

     ```javascript
     const fs = require("fs");
     
     fs.writeFile("./writeme.txt", "여기에 글을 썼다",(err, data) => {
         if(err){
             throw err;
         }
         
         fs.readFile("./writeme.txt", (err, data) => {
             if(err){
                 throw err;
             }
             
             console.log(data.toString());
         });
     });
     ```

     

     결과

     ![writeFile](https://user-images.githubusercontent.com/20276476/74396203-a1faa980-4e54-11ea-994e-8d52ae349914.png)

     writeme.txt가 생기고 내용을 읽어서 출력

     

#### 2. 동기 메서드, 비동기 메서드

* 노드는 대부분의 메서드를 비동기 방식으로 사용

  ###### 실습

  * readme2.txt

    ```txt
    저를 여러 번 읽어보세요.
    ```

    

  * async.js

    ```javascript
    const fs = require("fs");
    
    console.log("시작");
    fs.readFile('./readme2.txt', (err, data) => {
        if(err){	throw err;	}
        console.log('1번', data.toString());
    });
    
    fs.readFile('./readme2.txt', (err, data) => {
        if(err){	throw err;	}
        console.log('2번', data.toString());
    });
    
    fs.readFile('./readme2.txt', (err, data) => {
        if(err){	throw err;	}
        console.log('3번', data.toString());
    });
    console.log("끝");
    ```

    ![5](https://user-images.githubusercontent.com/20276476/81761141-261c0600-9504-11ea-8192-147d41a583ac.png)

    * 비동기 메서드들은 요청후 다음작업으로 넘어감
    * 그래서 실행 시 마다 결과가 달라진다

    

    * 동기- 비동기, 블로킹 - 논블로킹
      * 동기 - 비동기 : 함수가 바로 return 되는지 여부
      * 블로킹 - 논블로킹 : 백그라운드 작업 완료 여부

    

  * sync.js

    ```javascript
    const fs = require("fs");
    
    console.log("시작");
    
    let data = fs.readFileSync("./readme2.txt");
    console.log("1번", data.toString());
    
    data = fs.readFileSync("./readme2.txt");
    console.log("2번", data.toString());
    
    data = fs.readFileSync("./readme2.txt");
    console.log("3번", data.toString());
    
    console.log("끝");
    ```

    * async와 sync의 차이

      ![11](https://user-images.githubusercontent.com/20276476/81767019-5d91af00-9512-11ea-8f5b-a5db5d419477.png)

    * async는 요청을 계속 받으며 백그라운드에서 처리하도록 넘겨준다 -> 성능이 좋다

    * sync는 순서대로 작업을 하게 할 수 있지만 메인 스레드가 작업이 처리될 때 까지 기다려야 한다

    

  * 해결법은?

    * 비동기 함수에 콜백 함수로 다음 작업을 넣어주면 된다

    * asyncOrder.js

      ```javascript
      const fs = require("fs");
      
      console.log("시작");
      
      fs.readFile("./readme2.txt", (err, data) => {
          if(err){	throw err; }
          console.log("1번", data.toString());
          fs.readFile("./readme2.txt", (err, data) => {
              if(err){	throw err;	}
              console.log("2번", data.toString());
              fs.readFile("./readme2.txt", (err, data) => {
                  if(err){	throw err;	}
                  console.log("3번", data.toString());
              });
          });
      });
      
      console.log("끝");
      ```

      **문제점 : 콜백헬이 생긴다(계층적으로 계속 콜백함수가 생김**

      **promise, async/await로 어느정도 해결 가능**

  

#### 3. 버퍼와 스트림

* 버퍼 : 데이터 전송 시 까지 데이터를 모아놓음
* 스트림 : 바이트 단위로 데이터를 계속 보내줌



* 노드에서의 버퍼를 다루는 Buffer

  * buffer.js

    ```javascript
    const buffer = Buffer.from("저를 버퍼로 바꿔보세요");
    
    // 문자열을 버퍼로 바꿈
    console.log("from() : ", buffer);
    // 버퍼의 길이
    console.log("length : ", buffer.length);
    // 버퍼를 문자열로 바꿈
    console.log("toString() : ", buffer.toString());

    const array = [Buffer.from("띄엄 "), Buffer.from("띄엄 "), Buffer.from("띄어쓰기")];
    // 버퍼에 array를 붙임
    const buffer2 = Buffer.concat(array);
    console.log("concat():", buffer2.toString());
    
    // 새 버퍼를 할당
    const buffer3 = Buffer.alloc(5);
    console.log("alloc():", buffer3);
    ```
    
    문제점 : 처리해야 할 용량이 많아지면 그만큼 공간을 할당해야 한다





